<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Zhaohao Lin</title><meta name="author" content="Lachlan"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/blog/">Zhaohao Lin</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/blog/"> Publications</a></li><li class="menus_item"><a class="site-page" href="/blog/"> About</a></li><li class="menus_item"><a class="site-page" href="https://lachlanlin.gitee.io/blog/" target="_blank" rel="noopener"> Blog</a></li></ul></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/blog/img/avatar.jpg" onerror="this.onerror=null;this.src='/blog/img/profile.png'" alt="avatar"></div><div class="author-discrip"><h3>Lachlan</h3><p class="author-bio">Your biography can be writed down here.</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-icons"><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-facebook-square" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-github" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-stack-overflow" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-weibo" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-weixin" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fab fa-qq" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i></a></li><li><a class="social-icon" href="/" target="_blank"><i class="fas fa-rss" aria-hidden="true"></i></a></li></ul><ul class="social-links"><li><a class="e-social-link" href="/blog/" target="_blank"><i class="fas fa-graduation-cap" aria-hidden="true"></i><span>Google Scholar</span></a></li><li><a class="e-social-link" href="/blog/" target="_blank"><i class="fab fa-orcid" aria-hidden="true"></i><span>ORCID</span></a></li></ul></div><a class="cv-links" href="/blog/attaches/CV.pdf" target="_blank"><i class="fas fa-file-pdf" aria-hidden="true"><span>My Detail CV.</span></i></a></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">阅读SLAM相关论文系列----1</h2><article><h1 id="阅读SLAM相关论文-1"><a href="#阅读SLAM相关论文-1" class="headerlink" title="阅读SLAM相关论文(1)"></a>阅读SLAM相关论文(1)</h1><h2 id="1-DynaSLAM"><a href="#1-DynaSLAM" class="headerlink" title="1. DynaSLAM"></a>1. DynaSLAM</h2><p><a href="https://arxiv.org/abs/1806.05620" target="_blank" rel="noopener">论文链接</a></p>
<p>一个可以利用语义信息识别图像中物体是动态还是静态的SLAM.<br>SLAM的主体是ORB-SLAM2, 利用Mask R-CNN对语义信息进行提取, 同时利用多视图几何对物体的动态与否进行判断, 将两个方法的结果合并起来, 可以得到更好的效果, 将动态点作为离群点, 不考虑到定位与建图中, 论文中还进一步着重介绍他们的动态图像去除后恢复静态背景的功能, 不过暂时还不太成熟, 效果反而不如不恢复. 最后, 对该SLAM框架进行测试, 截止到论文发表为止, 在众多主流SLAM框架中, 取得了最好的效果.</p>
<h3 id="1-1-总体框架"><a href="#1-1-总体框架" class="headerlink" title="1.1 总体框架"></a>1.1 总体框架</h3><img src="/blog/2020/04/23/read-slam-papers-1/dynaslam-1.png" class="" title="总体框架">
<p>从图中可以看到, 输入的图像可以是单目的, 双目的, 或者RGB-D的, RGB图像经过Mask R-CNN, 直接生成了图像的掩膜, 掩膜区域内就是动态点. 另一边, 是使用多视图几何进行动态点的判断, 具体做法是: 选取关键帧中的5帧, 通过一个低成本的跟踪器, 计算当前帧的位姿, 然后计算某个特征点投影到当前帧的像素坐标和深度, 与该像素坐标上的当前深度作比较, 如果深度差超过一定阈值, 则判定为动态点, 同时周围一定范围内的等深度像素也都判定为动态点.<br><img src="/blog/2020/04/23/read-slam-papers-1/dynaslam-2.png" class="" title="多视图几何计算深度示意图"></p>
<h3 id="1-2-分割示例"><a href="#1-2-分割示例" class="headerlink" title="1.2 分割示例"></a>1.2 分割示例</h3><img src="/blog/2020/04/23/read-slam-papers-1/dynaslam-3.png" class="" title="多视图几何计算深度示示例">
<p>图中, 第一幅图是使用多视图几何进行图像分割的, 可以可以看到, 该算法把最前面的人, 椅子和人手上拿着的书都分割出来了, 但是无法分割后面躲着的人; 第二幅图是使用Mask R-CNN进行语义分割的, 可以看到, 它把前面的人和后面的人都准确地分割出来了, 但是, 它无法分割出来人坐着的椅子和手上拿着的书; 第三幅图是把前两种算法的结果合并了, 可以看到, 该算法不仅把前后的人物给分割出来, 椅子和书也都分割出来了</p>
<h3 id="1-3-效果对比"><a href="#1-3-效果对比" class="headerlink" title="1.3 效果对比"></a>1.3 效果对比</h3><p>使用的数据集是TUM数据集</p>
<img src="/blog/2020/04/23/read-slam-papers-1/dynaslam-4.png" class="" title="使用多视图和mrcnn的对比">
<p>上表表示多种图像分割算法的对比<br>N表示使用多视图几何;<br>G表示使用mrcnn;<br>N+G表示使用多视图几何加mrcnn;<br>N+G+BI表示使用多视图几何, mrcnn和静态背景恢复;</p>
<img src="/blog/2020/04/23/read-slam-papers-1/dynaslam-5.png" class="" title="DynaSLAM和ORB-SLAM2的对比">
<p>上表是RGB-D摄像头的DynaSLAM和ORB-SLAM2的效果对比, w代表场景走路walking, s代表场景坐下sitting. 可以看到在走路的高动态的场景中, DynaSLAM的效果比ORB-SLAM2的误差更小. 但是在坐下的低动态场景中, DynaSLAM的优势不怎么明显, 甚至比ORB-SLAM2还略低.</p>
<p>后缀意义如下:<br>(1) halfsphere: the camera moves following the trajectory of a 1-meter diameter half sphere,<br>(2) xyz: the camera moves along the x-y-z axes,<br>(3) rpy: the camera rotates over roll, pitch and yaw axes,<br>(4) static: the camera is kept static manually.</p>
<img src="/blog/2020/04/23/read-slam-papers-1/dynaslam-6.png" class="" title="DynaSLAM和其他语义或动态SLAM的对比">
<p>上表是DynaSLAM和动态SLAM的效果对比, 可以看到DynaSLAM几乎在各个场景中都是力压群雄.<br><img src="/blog/2020/04/23/read-slam-papers-1/dynaslam-7.png" class="" title="单目DynaSLAM和ORB-SLAM的对比"><br>上表是单目相机版的DynaSLAM和单目的ORB-SLAM的对比, 这一次DynaSLAM的精度不如ORB-SLAM, 论文的解释是DynaSLAM跟踪的路线比ORB-SLAM的更长, 所以累计误差比较多(反正我是不信). 这里我们还可以横向对比, 对比RGB-D的DynaSLAM和单目的DynaSLAM, 可以看到单目的DynaSLAM的误差少了那么一点点, 所以论文还做出了一个结论: 单目的SLAM更适合进行动态SLAM, 原因是单目和RGB-D的SLAM初始化方式不一样, 对于这一点, 我还没有找到根据, 但是从结果来看确实是这样.</p>
<h2 id="2-CubeSLAM"><a href="#2-CubeSLAM" class="headerlink" title="2. CubeSLAM"></a>2. CubeSLAM</h2><p><a href="https://arxiv.org/abs/1806.00557" target="_blank" rel="noopener">论文链接</a><br><a href="https://mp.weixin.qq.com/s/wYhltIpqEFj7ubI12umukg" target="_blank" rel="noopener">参考翻译</a><br>这是一个物体级别的SLAM框架, 把物体考虑进SLAM的求解当中, 利用单视图也就是一帧, 进行三维立方体拟合.</p>
<h3 id="2-1-三维立体表示"><a href="#2-1-三维立体表示" class="headerlink" title="2.1 三维立体表示"></a>2.1 三维立体表示</h3><p>在该SLAM中, 3维物体都抽象成一个立方体, 用一个9维向量描述, 除了6维刚体变换外，还增加了3个元素: 即立方体的长, 宽, 高.<br>由于一个前端矩形检测的四个端点只能提供4个约束, 因而需要其他的信息. 论文中使用消失点(Vanishing point)VP来改变和减少回归参数<br>消失点是中心投影中的概念, 指三维空间中平行的直线在二维投影空间中的交点. 如下图中黑点<br><img src="/blog/2020/04/23/read-slam-papers-1/cubeslam.png" class="" title="消失点"><br>3维立方体在二维平面中的投影大致可以分为三种情况, 3个面, 2个面, 一个面, 如下图:<br><img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-1.png" class="" title="VP法示意图"><br>以a图举例, 如果我们知道2D框, 三个消失点的坐标和上方的一个立方体角点的投影, 如1, 那我们就可以推断出整个立方体的8个角点在二维平面上的投影. 得到二维点之后进行反投影就可以得到三维点的坐标了. 论文中说可以通过物体的旋转R和相机内参K得到三个消失点. 所以现在问题就变成了如何得到物体的旋转和一个角点. 论文中提到三种方法:</p>
<ol>
<li><p>利用深度学习网络进行大量的训练, 直接预测物体的旋转R(此方法后文不再提及)</p>
</li>
<li><p>进行充分的采样, 评分选出最优的结果</p>
</li>
<li><p>对于平放在地面上的物体, 利用RPY计算旋转(论文进行测试时所用的方法, 论文也只对于平放在地面上物体进行测试, 此时R=0, P=0, 只有Y角可以不为0)</p>
</li>
</ol>
<p>对于第二个方法, 论文中给出了评分公式<br><img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-2.png" class="" title="评分公式"><br>其中, $\phi_{dist}$表示距离误差, 指提取出来的边缘和拟合的立方体的边之间的距离;</p>
<p>$\phi_{angle}$表示角度误差, 指消失点与角点的连线和检测出来的连线之间的误差;<br><img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-4.png" class="" title="角度误差计算公式"><br>$\phi_{shape}$表示形状误差, 将生成的2维点反投影到3维空间中, 计算不同边之间的长宽比, 加入惩罚, 这样可以筛除类似梯形的立方体;</p>
<p>示例效果如下图:<br><img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-3.png" class="" title="提案评分"></p>
<h3 id="2-2-BA优化问题"><a href="#2-2-BA优化问题" class="headerlink" title="2.2 BA优化问题"></a>2.2 BA优化问题</h3><p>总公式如下<br><img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-5.png" class="" title="BA优化公式"></p>
<p>下面逐项解释</p>
<ol>
<li><p>相机-物体误差</p>
 <img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-6.png" class="" title="相机-物体误差公式">
<p> 这个误差是表示成向量形式, 中间的空格是分开两个元素的, 我一开始一直看不懂这空格是干啥. 其中, $T_{om}$是当前帧预测的立方体坐标(包括位移和旋转6个量), $T_o$是SLAM建图中存储的该立方体的位姿, $T_c$是相机在世界坐标系中的位姿表示, 所以第一项的含义是预测的坐标和已有的坐标转换到相机坐标系下的坐标进行对比, 如果两个完全一样, 那么 $T^{-1}_c T_o T^{-1}_om$等于单位阵, 再通过se3转换为向量, 最后取对数; 矩阵的第二项就很简单, 是预测尺寸和已有尺寸的差</p>
</li>
<li><p>相机-点误差<br> 论文中使用了标准的重投影误差</p>
</li>
<li><p>物体-点误差</p>
 <img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-8.png" class="" title="物体-点误差">
<p> 如果点有属于某一个物体, 那么点在此物体内时, 误差为0, 否则是点与该物体的距离.</p>
</li>
</ol>
<h3 id="2-3效果示例"><a href="#2-3效果示例" class="headerlink" title="2.3效果示例"></a>2.3效果示例</h3><img src="/blog/2020/04/23/read-slam-papers-1/cubeslam-9.png" class="" title="效果示例">
<h2 id="3-港科大沈劭劼团队"><a href="#3-港科大沈劭劼团队" class="headerlink" title="3. 港科大沈劭劼团队"></a>3. 港科大沈劭劼团队</h2><p><a href="https://arxiv.org/abs/1807.02062" target="_blank" rel="noopener">论文链接</a></p>
<p>提出了一种粗略估计汽车视角的算法, 该算法将汽车的视角粗略的分为8个视角, 利用Faster R-CNN, 在网络的最后添加一个和生成2d框并行的全连接网络, 输出汽车的视角.<br><img src="/blog/2020/04/23/read-slam-papers-1/shenshaojie.png" class="" title="沈劭劼"></p>
<h2 id="4-Network-Uncertainty"><a href="#4-Network-Uncertainty" class="headerlink" title="4. Network Uncertainty"></a>4. Network Uncertainty</h2><p><a href="https://arxiv.org/abs/1811.11946" target="_blank" rel="noopener">论文链接</a></p>
<p>该论文使用信息熵判断观测数据是否用于更新估计的状态量.<br>对于统计变量X, 它的熵记为H(X), 在Y条件下记为H(X|Y), 两者的差值记为I(X;Y)<br><img src="/blog/2020/04/23/read-slam-papers-1/entropy-0.png" class="" title="信息熵公式"><br>论文中推导出了如下公式:<br><img src="/blog/2020/04/23/read-slam-papers-1/entropy-1.png" class="" title="论文推导的信息熵公式"><br>其中 $ H(x|Z) $ 表示在Z观测数据(一般指点)下, 位姿的不确定度, $ H(x|z_i, Z) $ 表示在加入了 $ z_i $ 观测点之后, x的不确定度变化, 加入语义信息之后, 还能得到如下公式:<br><img src="/blog/2020/04/23/read-slam-papers-1/entropy-2.png" class="" title="语义信息熵公式"><br>其中, $ H(c_i|I,D) $ 表示, 在数据集D, 输入图像为I下, 分类信息 $ c_i $ 的不确定度, 也就是说, 在使用D数据集训练的网络, 输入I图像, 得到的分类结果$ c_i $ , 它在各个类的分类概率越分散, 熵越大, 分类概率越集中, 熵越小.<br>它的特征点选择策略就是, 对每一个点计算该值, 该值越大, 越容易被选择.</p>
<h3 id="4-1-论文的意义"><a href="#4-1-论文的意义" class="headerlink" title="4.1 论文的意义"></a>4.1 论文的意义</h3><p>论文的意义就是可以在大量减少特征点的情况下, 保持跟原本差不多的精度.<br><img src="/blog/2020/04/23/read-slam-papers-1/entropy-3.png" class="" title="效果对比"></p>
<h2 id="5-关键帧选取方法"><a href="#5-关键帧选取方法" class="headerlink" title="5. 关键帧选取方法"></a>5. 关键帧选取方法</h2><p><a href="https://ieeexplore.ieee.org/abstract/document/8793923" target="_blank" rel="noopener">论文链接</a></p>
<ol>
<li><p>调整大小</p>
</li>
<li><p>使用拉普拉斯算子卷积计算模糊度, 实际就是计算梯度, 梯度越大, 得分越高</p>
</li>
<li><p>将图像投影到LAB色彩空间, 取L, 即亮度的值, 亮度越高, 得分越低</p>
</li>
<li><p>使用MiniNet进行语义分割, 得到语义得分(但是我没有看到怎么由结果得到得分)</p>
</li>
</ol>
<p>网络结构图如下<br><img src="/blog/2020/04/23/read-slam-papers-1/keyframe-1.png" class="" title="mininet网络结构图"></p>
<h2 id="6-CALC"><a href="#6-CALC" class="headerlink" title="6. CALC"></a>6. CALC</h2><p><a href="https://arxiv.org/abs/1805.07703" target="_blank" rel="noopener">论文链接</a></p>
<p>一种使用无监督学习神经网络的回环检测方法, 设计了一种自动编码结构. 它是一种轻量级的实时快速学习架构.</p>
<img src="/blog/2020/04/23/read-slam-papers-1/calc-1.png" class="" title="calc结构图">
<p>这是训练时的网络结构, 由两个卷积加池化层, 一个卷积层和三个全连接层组成, 训练完成之后保留黑框内的结构, 即一个输入层, 两个卷积加池化层和一个卷积层, 输出的就是图像的编码, 进行回环检测的时候直接对比图像的编码.<br>论文中还提到, 如果帧的数量比较多, 可以创建一个最近邻分类的KD树, 提高查询速度.</p>
<p>下面是不同数据集下查找结果对比<br><img src="/blog/2020/04/23/read-slam-papers-1/calc-2.png" class="" title="结果1"><br><img src="/blog/2020/04/23/read-slam-papers-1/calc-3.png" class="" title="结果2"><br><img src="/blog/2020/04/23/read-slam-papers-1/calc-4.png" class="" title="结果3"><br><img src="/blog/2020/04/23/read-slam-papers-1/calc-5.png" class="" title="结果4"><br><img src="/blog/2020/04/23/read-slam-papers-1/calc-6.png" class="" title="结果5"></p>
<p>下面是提取特征描述子和查找最相近的帧的耗时(查找方式使用的线性搜索)<br><img src="/blog/2020/04/23/read-slam-papers-1/calc-7.png" class="" title="速度对比"></p>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/blog/"> Publications</a></li><li class="nav_item"><a class="nav-page" href="/blog/"> About</a></li><li class="nav_item"><a class="nav-page" href="https://lachlanlin.gitee.io/blog/" target="_blank" rel="noopener"> Blog</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2020 - 2021 by Lachlan</div><div class="theme-info">Powered by <a href="https://hexo.io" target="_blank" rel="nofollow noopener">Hexo</a> & <a href="https://github.com/PhosphorW/hexo-theme-academia" target="_blank" rel="nofollow noopener">Academia Theme</a></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/blog/js/main.js"></script></body></html>